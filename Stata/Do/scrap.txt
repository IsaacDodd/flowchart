flowchart row, centername(referred) centertext(Referred)

tokenize "`centertext'", parse("!")
.blockfields=.object.new
.blockfields.Declare array list
forval index=1/`=`.blockfields.list.arrnels'' {
	display `"`.blockfields.list[`index']'"'
}


capture program drop flowchart_writeblock
program define flowchart_writeblock
   gettoken varfirst varothers : 0
   display "  Variables: `anything'"
   display " First Variable: `varfirst'"
   display " Others: " `varothers'
end
flowchart_writeblock row 46 "This is one row of a block." 43 "This is another row of a block" 3 "This is another row of a block"
flowchart_writeblock row, 46 "This is one row of a block.", 43 "This is another row of a block", 3 "This is another row of a block"
flowchart_writeblock row, (46) "This is one row of a block.", (43) "This is another row of a block", (3) "This is another row of a block"
flowchart_writeblock row: (46) "This is one row of a block.", (43) "This is another row of a block", (3) "This is another row of a block"
flowchart_writeblock row : (46) "This is one row of a block.", (43) "This is another row of a block", (3) "This is another row of a block"
flowchart_writeblock row: (46) "This is one row of a block.", (43) "This is another row of a block", (3) "This is another row of a block"
flowchart_writeblock row: (46), "This is one row of a block.", (43), "This is another row of a block", (3), "This is another row of a block"
flowchart_writeblock row: 46, "This is one row of a block.", 43, "This is another row of a block", 3, "This is another row of a block"




capture program drop flowchart_writeblock
program define flowchart_writeblock
   gettoken varfirst varothers : 0
   display "  Variables: `anything'"
   display " First Variable: `varfirst'"
   display " Others: " `varothers'
   display `"0 = `0'"'
   display `"1 = `1'"'
   display `"2 = `2'"'
   display `"3 = `3'"'
   display `"4 = `4'"'
   display `"5 = `5'"'
   display `"6 = `6'"'
   display `"7 = `7'"'
   display `"8 = `8'"'
   display `"9 = `9'"'
   display `"10 = `10'"'
   display `"11 = `11'"'
   display `"12 = `12'"'
   local i = 1
   while "``1''" != "" {
      display ``i''
      local i = `i' + 1
   }
end

flowchart_writeblock row: 46, "This is one row of a block.", 43, "This is another row of a block", 3, "This is another row of a block"
flowchart_writeblock row: 46 "This is one row of a block." 43 "This is another row of a block" 3 "This is another row of a block"
flowchart_writeblock row: 46 "This is one row of a block." 43 "This is another row of a block" 3 "This is another row of a block",  97 "This is one row of a block." 33 "This is another row of a block" 44 "This is another row of a block"


flowchart_writeblock row: 46 "This is one row of a block." 43 "This is another row of a block" 3 "This is another row of a block",  97 "This is one row of a block." 33 "This is another row of a block" 44 "This is another row of a block"

* Format: flowchart_writeblock [row]: [left-block], [right-block]



* With commas in the sentences, a test of tokenization: 
flowchart_writeblock row: 46 "This is one row, of a block." 43 "This is another row, of a block" 3 "This is another row, of a block",  97 "This is one row, of a block." 33 "This is another row, of a block" 44 "This is another row, of a block"









capture program drop flowchart_writeblock
program define flowchart_writeblock
   gettoken varfirst varothers : 0
   display ""
   display " First Variable: `varfirst'"
   display ""
   display "Macro Without Quotes: " `varothers'
   display ""
   display `"Compound Quotes (CQ's):  `varothers'"'
   display ""
   display `"Entire Statement (With CQ's): `0'"'
   display ""

   display `"Tokens:"'
   display ""
   local i = 1
   while "``i''" != "" {
      display "`i': ``i''"
      display ""
      local i = `i' + 1
   }
end

* Without programmatic rownames
flowchart_writeblock row: 46 "This is one row, of a block." 43 "This is another row, of a block" 3 "This is another row, of a block",  97 "This is one row, of a block." 33 "This is another row, of a block" 44 "This is another row, of a block"

* With Programmatic RowNames
flowchart_writeblock row: "lblock_row1" 46 "This is one row, of a block." "lblock_row2" 43 "This is another row, of a block" "lblock_row3" 3 "This is another row, of a block", "rblock_row1" 97 "This is one row, of a block." "rblock_row2" 33 "This is another row, of a block" "rblock_row3" 44 "This is another row, of a block"

* Example of usage with lines broken for clarification:
flowchart_writeblock row: /// 
	* Left Block
	"lblock1_row1" 46 "This is one row, of a block." /// 
	"lblock1_row2" 43 "This is another row, of a block" /// 
	"lblock1_row3" 3 "This is another row, of a block", ///
	* Right Block
	"rblock1_row1" 97 "This is one row, of a block." ///
	"rblock1_row2" 33 "This is another row, of a block" ///
	"rblock1_row3" 44 "This is another row, of a block"

* With rowname specified:
flowchart_writeblock row(row_name): "lblock1_row1" 46 "This is one row, of a block." "lblock1_row2" 43 "This is another row, of a block" "lblock1_row3" 3 "This is another row, of a block", "rblock1_row1" 97 "This is one row, of a block." "rblock1_row2" 33 "This is another row, of a block" "rblock1_row3" 44 "This is another row, of a block"

* Note: A single row = a left block and a right block. A single ',' divides the left block from the right block. Each block consists of a collection of lines. A single line has a description and number (n=#) associated with it. 
* If there is only 1 line, it is centered. If there are more than one line, the first line is the leading line and the others are enumerated and indented.






capture program drop flowchart_writeblock
program define flowchart_writeblock
	syntax [anything] [using/] [, name(string) value(string) input(string) output(string) *]

	* Parse the token for a possible sub-command that contains a command (e.g., flowchart subcommand(parameter): ... )
	gettoken subcmd 0 : 0, parse(" :") quotes
	while `"`subcmd'"' != ":" & `"`subcmd'"' != "" {
		local subcmdwithparam `"`subcmdwithparam' `subcmd'"'
		gettoken subcmd 0 : 0, parse(" :") quotes
	}
	display ""
	display "Subcommand via GetToken: `subcmd'"
	display "Subcommand via Syntax: `1'"
	display `"Subcommand With Parameter: `subcmdwithparam'"'
	display `"Compound Quotes (CQ's):  `0'"'
	local subparam = substr("`subcmdwithparam'", strpos("`subcmdwithparam'", "(")+1, length("`subcmdwithparam'")-strpos("`subcmdwithparam'", "(")-1)
	local subcmdparsed = substr("`subcmdwithparam'", 1, strpos("`subcmdwithparam'", "(")-1)
	display `"Subparameter via String Parse (CQ's):  `subparam'"'
	display `"Subcommand via String Parse (CQ's):  `subcmdparsed'"'
	
	if("`1'" == "writerow:" | "`1'" == "writerow" | "`subcmdparsed'" == "writerow" | trim("`subcmdparsed'") == "writerow") {
		gettoken varfirst varothers : 0
		display ""
		display " First Variable: `varfirst'"
		display ""
		display "Macro Without Quotes: " `varothers'
		display ""
		display `"Compound Quotes (CQ's):  `varothers'"'
		display ""
		display `"Entire Statement (With CQ's): `0'"'
		display ""

		display `"Tokens:"'
		display ""
		local i = 1
		while "``i''" != "" {
			display "`i': ``i''"
			display ""
			local i = `i' + 1
		}
	}
end

flowchart_writeblock writerow(row_name): "lblock1_line1" 46 "This is one row, \\ of a block." "lblock1_line2" 43 "This is another row, of a block" "lblock1_line3" 3 "This is another row, of a block", "rblock1_line1" 97 "This is one row, of a block." "rblock1_line2" 33 "This is another row, of a block" "rblock1_line3" 44 "This is another row, of a block"








capture program drop flowchart_writeblock
program define flowchart_writeblock
	syntax [anything] [using/] [, name(string) value(string) input(string) output(string) *]

	* Parse the token for a possible sub-command that contains a command (e.g., flowchart subcommand(parameter): ... )
	gettoken subcmd 0 : 0, parse(" :") quotes
	while `"`subcmd'"' != ":" & `"`subcmd'"' != "" {
		local subcmdwithparam `"`subcmdwithparam' `subcmd'"'
		gettoken subcmd 0 : 0, parse(" :") quotes
	}
	display ""
	display "Subcommand via GetToken: `subcmd'"
	local subcmdsyntax = "`1'"
	display "Subcommand via Syntax: `subcmdsyntax'"
	display `"Subcommand With Parameter: `subcmdwithparam'"'
	display `"Compound Quotes (CQ's):  `0'"'
	local subparam = substr("`subcmdwithparam'", strpos("`subcmdwithparam'", "(")+1, length("`subcmdwithparam'")-strpos("`subcmdwithparam'", "(")-1)
	local subcmdparsed = substr("`subcmdwithparam'", 1, strpos("`subcmdwithparam'", "(")-1)
	display `"Subparameter via String Parse (CQ's):  `subparam'"'
	display `"Subcommand via String Parse (CQ's):  `subcmdparsed'"'
	
	if("`1'" == "writerow:" | "`1'" == "writerow" | "`subcmdparsed'" == "writerow" | trim("`subcmdparsed'") == "writerow") {
		gettoken varfirst varothers : 0
		display ""
		display " First Variable: `varfirst'"
		display ""
		display "Macro Without Quotes: " `varothers'
		display ""
		display `"Compound Quotes (CQ's):  `varothers'"'
		display ""
		display `"Entire Statement (With CQ's): `0'"'
		display ""

		display `"Tokens:"'
		display ""
		
		
		local i = 1
		local blockparse = "center"
display `"      % Row - `subparam'"'
		
		while "``i''" != "" {
			display "`i': ``i''"
			
			if("``i''" == "`subcmdparsed'" | trim("``i''") == "`subcmdwithparam'" | trim("``i''") == "`subcmdsyntax'") {
				local i = `i' + 1
				continue
			}
			else if(trim("``i''") == ",") {
				* If a comma is encountered, switch the blockparse flag to parse the left block (lblock) instead of the center block (cblock).
				local blockparse = "left"
				local i = `i' + 1
				continue
			}
			
			* Generate a Look-Ahead Macro: This allows the conditional if statements determine the end of a block. Each line always comes in 3, so look 3 values ahead to see if there is a comma. If there is a comma, then the present line is the last line in the block.
			local ilookahead = `i' + 3
			display `"			LA: ``ilookahead'' "'
			
			if("`blockparse'" == "center") {
				local cblock_string_node = `"\node [block_`blockparse'] (``i'')"'
				local i = `i' + 1
				local cblock_string_n = `"(n=\figvalue{``i''})"'
				local i = `i' + 1
				local cblock_string_lead = `"``i''"'
display `"      `cblock_string_node' {`cblock_string_lead' `cblock_string_n'};"'
			} 
			else if("`blockparse'" == "left") {
				local lblock_string_node = `"\node [block_`blockparse'] (``i'')"'
				local i = `i' + 1
				local lblock_string_n = `"(n=\figvalue{``i''})"'
				local i = `i' + 1
				local lblock_string_lead = `"``i''"'
display `"      & `lblock_string_node' {`lblock_string_lead' `lblock_string_n'};"'
				
				* Set the block back to the center block for the next row.
				local blockparse = "center"
			}
*display `"      & \node [block_left] (excluded1) {Excluded (n=\figvalue{referred_excluded}): \\"'
*display `"        a) Did not wish to participate (n=\figvalue{referred_excluded_nopartic}) \\"'
*display `"        b) Did not show for interview (n=\figvalue{referred_excluded_noshow}) \\"'
*display `"        c) Other reasons (n=\figvalue{referred_excluded_other})}; \\"'

			local i = `i' + 1
		}
	}
end

flowchart_writeblock writerow(row_name): "referred" 173 "Referred" "lblock1_line2" 43 "This is another row, of a block" "lblock1_line3" 3 "This is another row, of a block", "rblock1_line1" 97 "This is one row, of a block." "rblock1_line2" 33 "This is another row, of a block" "rblock1_line3" 44 "This is another row, of a block"




flowchart writerow(enrollment): ///
	
	"lblock1_line1" 46 "This is one line, \\ of a block." ///
	"lblock1_line2" 43 "This is another line, of a block" ///
	"lblock1_line3" 3 "This is another line, of a block", ///
	
	"rblock1_line1" 97 "This is one line, of a block." ///
	"rblock1_line2" 33 "This is another line, of a block" ///
	"rblock1_line3" 44 "This is another line, of a block"



	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
* DISPOSITION SUBANALYSIS: Analyze and setup the subject disposition.


* DIAGRAM: Call Post-Production texdoc file to write this analysis as a diagram.

capture program drop flowchart
*! version 0.0.1  28jul2017  Isaac M. E. Dodd
program define flowchart
	version 13
	syntax [anything] [using/] [, name(string) value(string) input(string) output(string) *]
	
	if("`1'" == "init" | "`1'" == "init,") {
		global Flowchart_Settings = ""
		capture file close FlowchartFile
		file open FlowchartFile using "`using'", write text replace
		flowchart_init
	}
	else if("`1'" == "close" | "`1'" == "finalize" | "`1'" == "close," | "`1'" == "finalize," ) {
		if("$Flowchart_Debug" == "on") {
			display "Closed."
		}
		capture file close FlowchartFile 
		flowchart_tdfinalize, input("`input'") output("`output'")
	}
	else if("`1'" == "write") {
		if("`2'" == "box" | "`2'" == "box,") {
			if("$Flowchart_Debug" == "on") {
				display "Write: `2' `name' `value'"
			}
			flowchart_writevar, name("Test") value("Testing testing 1 2 3 5 6 7 8 9 10 ...")
		}
		else if("`2'" == "row" | "`2'" == "row,") {
			if("$Flowchart_Debug" == "on") {
				display "Write: `2' `name' `value'"
			}
		}
	}
	else if("`1'" == "newbox") {
		if("$Flowchart_Debug" == "on") {
			display "New Box: `1' `2'"
		}
	}
	else {
	
		* Parse the token for a possible sub-command that contains a parameter (e.g., flowchart subcommand(parameter): ... )
		* 	This is necessary since Stata's 'syntax' command returns the subcommand token `1' with a colon. This method ensures the proper string is parsed.
		gettoken subcommand 0 : 0, parse(" :") quotes
		while `"`subcommand'"' != ":" & `"`subcommand'"' != "" {
			local subcmdwithparam `"`subcmdwithparam' `subcommand'"'
			
			gettoken subcommand 0 : 0, parse(" :") quotes
			if("$Flowchart_Debug" == "on") {
				display ""
				display `"Subcommand via GetToken: `subcommand'"'
			}
			local subcmdsyntax = "`1'"
			if("$Flowchart_Debug" == "on") {
				display "Subcommand via Syntax: `subcmdsyntax'"
				display `"Subcommand with Parameter: `subcmdwithparam'"'
				display `"Compound Quotes (CQ's):  `0'"'
			}
		}
		* Parse the possible sub-command with parameter, accounting for any whitespace within the passed parameter and subcommand.
		local subparam = trim(substr(trim("`subcmdwithparam'"), strpos(trim("`subcmdwithparam'"), "(")+1, length(trim("`subcmdwithparam'"))-strpos(trim("`subcmdwithparam'"), "(")-1))
		local subcmdparsed = substr(trim("`subcmdwithparam'"), 1, strpos(trim("`subcmdwithparam'"), "(")-1)
		if("$Flowchart_Debug" == "on") {
			display `"Subparameter via String Parse (CQs):  `subparam'"'
			display `"Subcommand via String Parse (CQs):  `subcmdparsed'"'
		}
			
		if("`1'" == "writerow:" | "`1'" == "writerow" | "`subcmdparsed'" == "writerow" | trim("`subcmdparsed'") == "writerow") {
	
			gettoken varfirst varothers : 0
			if("$Flowchart_Debug" == "on") {
				display ""
				display " First Variable: `varfirst'"
				display ""
				display "Macro Without Quotes: " `varothers'
				display ""
				display `"Compound Quotes (CQ's):  `varothers'"'
				display ""
				display `"Entire Statement (With CQ's): `0'"'
				display ""

				display `"Tokens:"'
				display ""
			}
			
			local i = 1		// Token Iterator
			local blockparse = "center"
flowchart_tdwrite `"      % Row - `subparam'"'

			while "``i''" != "" {
				if("$Flowchart_Debug" == "on") {
					display "`i': ``i''"
				}
				
				if("``i''" == "`subcmdparsed'" | trim("``i''") == "`subcmdwithparam'" | trim("``i''") == "`subcmdsyntax'") {
					local i = `i' + 1
					continue
				}
				else if(trim("``i''") == ",") {
					* If a comma is encountered, switch the blockparse flag to parse the left block (lblock) instead of the center block (cblock).
					local blockparse = "left"
					local i = `i' + 1
					continue
				}
				
				* Generate a Look-Ahead Macro: This allows the conditional if statements determine the end of a block.
				local ilookahead = `i' + 3
				if("$Flowchart_Debug" == "on") {
					display `"			LA: ``ilookahead'' "'
				}
				
				if("`blockparse'" == "center") {
	flowchart_tdwrite `"      \node [block_`blockparse'] (`subparam'_`blockparse') {"'	
				} // fi: End of BlockParse
				else if("`blockparse'" == "left") {
	flowchart_tdwrite `"      & \node [block_`blockparse'] (`subparam'_`blockparse') {"'	
				} // fi: End of BlockParse
				
				local k = 1	// Line Iterator
				local stop = ""
				while("`stop'" == "") {	// while: LineWhile
					if(trim("``i''") == ",") {	// Inept
						local blockparse = "left"
						local stop = "stop"
						break
					}
					local linename = `"``i''"'
					local i = `i' + 1
					if("$Flowchart_Debug" == "on") {
						display "	iter: `i'"
						display "	lnum: ``i''"
					}
					local linenum = `"``i''"'
					flowchart_writevar, name(`"`linename'"') value(`"`linenum'"') // Store the number as the named line's number value.
					local i = `i' + 1
					if("$Flowchart_Debug" == "on") {
						display "	iter: `i'"
						display "	desc: ``i''"
					}
					local linedesc = `"``i''"'
					if("$Flowchart_Debug" == "on") {
						display "   Added to Block - Line `k': "
					}
					if(`k' == 1) {
						flowchart_tdwriteline, name(`"`linename'"') num(`"`linenum'"') desc(`"`linedesc'"') lead
					}
					else if(trim("``ilookahead''") == ",") {
						flowchart_tdwriteline, name(`"`linename'"') num(`"`linenum'"') desc(`"`linedesc'"') end
					}
					else {
						flowchart_tdwriteline, name(`"`linename'"') num(`"`linenum'"') desc(`"`linedesc'"') 
					}
					if("$Flowchart_Debug" == "on") {
						display " ---- "
						display ""
					}
					local k = `k' + 1
					local i = `i' + 1
					local ilookahead = `ilookahead' + 3
					if("$Flowchart_Debug" == "on") {
						display `"			LA: ``ilookahead'' "'
					}
					if(trim("``i''") == "," | "``i''" == "") {
						local blockparse = "left"
						local stop = "stop"
					}
						
				} // elihw: End of LineWhile
	flowchart_tdwrite `"      }; \\ "'				
				local i = `i' + 1
			} // elihw: End of TokenWhile
		} // fi: End of Writerow
	} // fi: End of SyntaxCmdElse
end
capture program drop flowchart_debug
program define flowchart_debug
	global Flowchart_Debug = "on"
end
capture program drop flowchart_init
program define flowchart_init
	flowchart_writevar, name("set_dummy") value("null")	// Set dummy variable since the first variable is not recognized by texdoc.
	flowchart_writevar, name("set_draw") value("black")
	flowchart_writevar, name("set_fill") value("white")
	flowchart_writevar, name("set_center_textwidth") value("8em")
	flowchart_writevar, name("set_center_textalign") value("centered")
	flowchart_writevar, name("set_center_minheight") value("4em")
	flowchart_writevar, name("set_left_textwidth") value("16em")
	flowchart_writevar, name("set_left_textalign") value("ragged")
	flowchart_writevar, name("set_left_minheight") value("4em")
	flowchart_writevar, name("set_left_innersep") value("6pt")
	flowchart_writevar, name("set_noborder_textwidth") value("18em")
	flowchart_writevar, name("set_noborder_textalign") value("centered")
	flowchart_writevar, name("set_noborder_minheight") value("1em")
	flowchart_writevar, name("set_noborder_draw") value("none")
	flowchart_writevar, name("set_noborder_fill") value("none")
	flowchart_writevar, name("set_assign_textwidth") value("18em")
	flowchart_writevar, name("set_assign_textalign") value("ragged")
	flowchart_writevar, name("set_assign_minheight") value("3em")
	flowchart_writevar, name("set_assign_innersep") value("6pt")
	flowchart_writevar, name("set_lost_textwidth") value("16em")
	flowchart_writevar, name("set_lost_textalign") value("ragged")
	flowchart_writevar, name("set_lost_minheight") value("3em")
	flowchart_writevar, name("set_lost_innersep") value("6pt")
end
capture program drop flowchart_writevar
program define flowchart_writevar
	syntax [anything] [, name(string) value(string) *]	
	local variablerow "`name' = `value'"
	file write FlowchartFile "`variablerow'" _n
	if(substr("`name'",1,4) == "set_") {
		global Flowchart_Settings = `"$Flowchart_Settings @`name'"'
		global Flowchart_Settings = `"$Flowchart_Settings "`value'""'
	}
end

capture program drop flowchart_tdfinalize
program define flowchart_tdfinalize
	syntax , input(string) output(string)
	***\\ TIKZ PICTURE: Write the TikZ Picture to the file.
	if("$Flowchart_Debug" == "on") {
		display "`input' `output'"
	}
	texdoc do "`input'", init("`output'") replace
	* Important Note: The '.tikz' extension here is important since if it is not specified, calling 'texdoc do' in the Main Analysis Do File will overwrite the .tex file of the same name in the same directory.
	texdoc close
end


capture program drop flowchart_tdwrite
program define flowchart_tdwrite
	syntax [anything] [, indent]
	display  "`1'"
	if("$Flowchart_Debug" == "on") {
		display  "1=|`1'|, 2=|`2'|, 3=|`3'| indent=|`indent'|"
	}
*	texdoc write "`varname'"
end

capture program drop flowchart_tdwriteline
program define flowchart_tdwriteline
	syntax [anything] [, indent lead end name(string) num(string) desc(string)]
	if("`lead'" != "") {
		local linestring = `"        `desc' (n=\figvalue{`name'}): \\ "'
	}
	else {
		if("`indent'" != "") {
			local linestring = `"        \h\h \figvalue{`name'} `desc' \\ "'
		}
		else {
			local linestring = `"        \h `desc' (n=\figvalue{`name'}) \\ "'
		}
	}
flowchart_tdwrite `"`linestring'"'
*	texdoc write "`varname'"
end

* ---------------------------------------------------------------------

flowchart init using "..\Data\Subanalysis Data\Methods--Fig-TEST.data"

*flowchart write box, name("Test")
*flowchart write box, name("TestBoxName") value("TestBoxValue")
*flowchart write row, name("TestRow")
*flowchart write row, name("TestRowName") value("TestRowValue")
*flowchart write row

*display `" $Flowchart_Settings "'

flowchart writerow(enrollment): "lblock1_line1" 46 "This is one line, \\ of a block." "lblock1_line2" 43 "This is another line, of a block" "lblock1_line3" 3 "This is another line, of a block", ///
	"rblock1_line1" 97 "This is one line, of a block." "rblock1_line2" 33 "This is another line, of a block" "rblock1_line3" 44 "This is another line, of a block"

flowchart finalize, input("98-IQSCVDMort-PostProduction-Methods--Fig-Flowchart.texdoc") output("..\..\Manuscript\04-IQSCVDMort-Methods--Fig-TEST.tikz")














clear all
.occup=.object.new
.occup.Declare array list
.occup.list[1]="Technology officer"
.occup.list[2]="Arts and Media Personnel"
.occup.list[3]="Records Management"
.occup.list[4]="Security Personnel"
.occup.list[5]="Front office"
.occup.list[6]="Back office"

display `"`.occup.list[1]'"'
display `"`.occup.list[2]'"'

forval f=1/`=`.occup.list.arrnels'' {
  display `"`.occup.list[`f']'"'
}




.Global.blockfields=.object.new
.Global.pathfields=.object.new
.Global.blockfields.Declare array list
.Global.pathfields.Declare array list
forval index=1/`=`.blockfields.list.arrnels'' {
	display `"`.blockfields.list[`index']'"'
}














